#!/usr/bin/env python3

from amaranth import *
from amaranth_twstft.Prescaler import *
from amaranth_twstft.globalcounter import *
from amaranth_twstft.prn import *
from amaranth.sim import *
import argparse
from math import log

#default number of different taps to choose among when dynamically selecting the taps for the LFSR
nb_taps_auto = 32

class Synchronizer(Elaboratable):
	"""
	A module that generates a n-bits PRN synchronized with a 1-PPS Signal in input.
	Whenever the noise restarts everytime the pps signal is asserted and is tropped everytime 
	the number of bits emitted equals the noise_len value
	
    Parameters
    ----------
    freqin : positive integer
		the frequency of the clock used by the fpga
	
	freqout : positive integer
		frequency we want to use to set the cadence of our PRN generation
		
	bit_len : positive integer
		number of bits of the LFSR
	
	noise_len : positive integer
		number of bits that should be generated by the Pseudo-Random Noise Generator befor any reset
		
	taps : non negative integer 
		taps that should be used for the LFSR (set to 0 by default, 0 means the taps are chosen dynamically)
	
	seed : positive integer
		initial state of the LFSR
	
	mode :
		1 for BPSK modulation (default)
		2 for QPSK modulation
		number of bits to shift the LFSR every 1/freqout seconds
		
    Attributes
    ----------
	output : Signal()
		the output of the module
		it equals the PRN when a 1-PPS Signal has been 
		received within the last second (defined by the fpga's clock domain)
		Else, it equals 0 
	pps : Signal()
		the 1-PPS signal transmitted by the precise frequency source
	
	noise_len : integer
		the number of bits to generate with our PRN
	
	_freqin : integer
		the frequency of the fpga's clock
	
	_freqout : integer
		the frequency of our PRN Generation
	
	_cnt : GlobalCounter(x, y)
		y is the value up to which  to count to
		x is the number of bits of our counter
		a module which counts up to a certain value and 
		outputs 0 when it reaches it, 1 otherwise. 
		Can be resetted through its reset input signal.
		
	mode : Signal()
		0 for BPSK modulation
		1 for QPSK modulation
		number of bits to shift the LFSR every 1/freqout seconds
		it also multiplies the frequency of the PRN generation to keep the same prn_rate
	
	shifting : Signal()
		output signal indicating that the LFSR is shifting
    """

	def __init__(self, freqin, freqout, bit_len, noise_len, reload=True, taps=0, seed = 0x1):
		self.pps = Signal(name="sync_pps_input")
		self.output = Signal(name="sync_output")
		self.output2 = Signal(name="sync_output2")
		self.shifting = Signal(name="shifting_prn_signal")
		self.mode = Signal()
		
		if taps == 0:
			self.dynamic_taps = True
			self.tsel = Signal(int(log(nb_taps_auto,2)), name="taps_selector_sync")
		else :
			self.dynamic_taps = False
			self.taps = taps
		
		self.seed = seed
		self.noise_len = noise_len
		self._reload = reload
		self._freqin = freqin
		self._freqout = freqout
		self._bit_len = bit_len
		self._cnt = GlobalCounter(self.noise_len, reload)
		self.rise_pps = Signal()
	
	def elaborate(self, platform):
		m = Module()
		
		#detecting the pps rising edge by buffering it
		pps_1 = Signal()
		pps_2 = Signal()
		pps_old = Signal()
		m.d.sync += [
			pps_1.eq(self.pps),
			pps_2.eq(pps_1),
			pps_old.eq(pps_2)
		]
		m.d.comb += self.rise_pps.eq((pps_2 ^ pps_old) & pps_2)
		
		#defining the taps to use
		if self.dynamic_taps :
			m.submodules.prn = prn = PrnGenerator(self._bit_len, seed = self.seed)
			m.d.comb += prn.tsel.eq(self.tsel)
		else :
			m.submodules.prn = prn = PrnGenerator(self._bit_len, taps=self.taps, seed=self.seed)
		
		
		#defining the frequency of the prn generation
		m.submodules.presc = presc = Prescaler(self._freqin, self._freqout )
		
		#Making the prn generate 2 bits instead of one when the prescaler ticks 
		#(for QPSK modulation only)
		#and signaling the LFSR is currently shifting
		next_qpsk = Signal()
		m.d.sync+= next_qpsk.eq(0)
		with m.If(self.mode):
			m.d.sync += next_qpsk.eq(presc.output)
		m.d.comb += [
			self.shifting.eq(presc.output | next_qpsk),
			prn.next.eq(self.shifting),
		]
		
		#counting the number of prn bits generated
		m.submodules.globCnt = self._cnt 
		m.d.comb+= [
			self._cnt.tick.eq(presc.output),
		]
		
		
		#enabling prn generation when the counter is still active 
		#and when pps isn't rising
		m.d.comb += [
			presc.enable.eq(self._cnt.output & ~self.rise_pps),
			prn.enable.eq(self._cnt.output & ~self.rise_pps & ~self._cnt.overflow),
		]
		
		#resetting the counter when the pps is received
		m.d.comb += self._cnt.reset.eq(self.rise_pps)
		
		
		#outputing the signals I and Q 
		# and updating them only when the LFSR isn't shifting
		old_output = Signal()
		old_output2 = Signal()
		
		m.d.comb += [
			self.output.eq(old_output),
			self.output2.eq(old_output2)
		]
		m.d.sync += [
			old_output.eq(old_output),
			old_output2.eq(old_output2)
		]
		with m.If(~self.shifting):
			m.d.sync += [
				old_output.eq(prn.output),
				old_output2.eq(prn.output2)
			]
		
		return m



if __name__ == "__main__" :
	
	parser = argparse.ArgumentParser()
	parser.add_argument("--bitlen", help="number of bits of the LFSR (default 22)", type=int)
	parser.add_argument("--noiselen", help="length of the PRN sequence", type=int)
	parser.add_argument("--seed", help="initial value of the LFSR", type=int)
	parser.add_argument("--taps", help="taps positions for the LFSR", type=int)
	args = parser.parse_args()
	if args.bitlen :
		b = args.bitlen
	else :
		b = 22
	if args.noiselen :
		n = args.noiselen
	else :
		n = 0
	if args.seed:
		s = args.seed
	else :
		s = 0x1
	if args.taps :
		t = args.taps
	else:
		t = 0
	dut = Synchronizer(100000,25000, bit_len = b, seed = s, taps = t, noise_len=n)
	sim = Simulator(dut)
	
	def proc():
		
		#2 seconds before the first pps
		for i in range(200000):
			yield Tick()
		print("2 sec")
		
		#simulating a pps
		yield dut.pps.eq(1)
		yield Tick()
		yield dut.pps.eq(0)
		
		#waiting 1 second (
		for i in range(100000):
			yield Tick()
		print("1 sec")
		
		#simulating an interrupted pps 
		yield dut.pps.eq(1)
		yield Tick()
		yield dut.pps.eq(0)
		for i in range(50000):
			yield Tick()
		print(".5 sec")
		yield dut.pps.eq(1)
		yield Tick()
		yield dut.pps.eq(0)
		for i in range(100000):
			yield Tick()
		print("1 sec")
		#simulating a regular pps
		for j in range(3):
			yield dut.pps.eq(1)
			yield Tick()
			yield dut.pps.eq(0)
			for i in range(100000):
				yield Tick()
			
	sim.add_clock(1e-5)
	sim.add_process(proc)
	with sim.write_vcd("test.vcd"):
		sim.run()
